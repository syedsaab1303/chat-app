node -e "console.log(require('crypto').randomBytes(64).toString('hex'))"
this command is used to generate random string which we used in JWT_SECRET



3. Data Flow Summary:
User Interaction:

User Login form mein apna email aur password enter karta hai.
User form ko submit karta hai.
State Update:

Login component ke state (email aur password) update hote hain user input ke through.
Login Function Call:

handleSubmit function ke andar, login(email, password) call kiya jata hai jo AuthProvider ke login function ko invoke karta hai aur current component ke email aur password state values ko pass karta hai.
Authentication Process:

AuthProvider ka login function backend server (via authService.login) ko request bhejta hai.
Agar authentication successful hota hai, toh user state update hota hai aur token localStorage mein store ho jata hai.
Post-Login Navigation:

Successful login ke baad, user ko home page (/) par navigate kiya jata hai.


Visual Representation:
[User] --> [Login Component]
    |           |
    |-- Inputs (email, password)
    |           |
    |-- On Submit -->
                  |
              [AuthProvider]
                  |
          login(email, password)
                  |
          [authService.login]
                  |
          Backend Authentication
                  |
              Response
                  |
          [AuthProvider updates state]
                  |
              [Login Component navigates]


Conclusion:
AuthProvider ke login function mein email aur password parameters external components se pass kiye jaate hain,
jaise ki Login.js. Yeh values user input se aati hain, jo form submit hone par state ke  through login 
function ko provide ki jaati hain. Is tarah se, AuthProvider ko pata hota hai ki user ko authenticate karne
ke liye kaunse credentials use karne hain, bina directly user input se interact kiye.

// visual flow in Login.js


Visual Flow:
Extract Function:

const { login } = useAuth();
(Login function ready for future use)
User Input:

const [email, setEmail] = useState('');
const [password, setPassword] = useState('');
(Input fields updated by user)
Form Submission:

login(email, password);
(Login function now uses the email and password provided by the user)

----------------------------**********************************************---------------------------------


ChatRoom.js 

/* Sending Messages: Jab user apna message type kar ke "send" button press karta hai, to sendMessage
 function backend ko wo message send kar deta hai. Backend phir us message ko sab users tak broadcast
 kar deta hai jo us chat room me hain. */

/* Receiving Messages: Jab backend se koi message aata hai, to socket.on('message') event us message ko
catch karta hai aur state me add kar deta hai taake wo chat window me dikh sake. */
NOTE:- ChatRoom.js  se flow charSocket.js me jayega

Overall Flow:
User Connects: User jab chat room kholta hai to socket server se connect ho jata hai.
Join Room: User kisi specific room, jaise 'general', me join hota hai.
Send Message: User apna message type karke send karta hai. Wo message backend ko send hota hai, jo phir us room ke sab users ko wo message bhej deta hai.
Receive Message: Backend se message receive hota hai aur frontend pe chat list me dikh jata hai.






// Backend aur Frontend Connection Explanation:
1) Real-Time Communication:
Jab frontend ka ChatRoom component load hota hai, to wo backend ke saath WebSocket connection create karta hai using io('http://localhost:5000').
Backend me chatSocket.js file ke andar ye connection handle kiya jata hai. Jab user connect hota hai, join hota hai kisi chat room me, ya message send
karta hai, to ye saari information real-time me backend aur frontend ke beech exchange hoti hai.

2) Join Room:
Jab user frontend se chat room join karta hai (socket.emit('joinRoom', chatRoom)), to backend ko pata chal
jata hai aur wo user ko us specific chat room me add kar leta hai.

3) Send Message:
Jab user message send karta hai (socket.emit('sendMessage', messageData)), to backend us message ko receive 
karta hai aur phir us room ke sabhi users tak wo message broadcast kar deta hai.

4) Receive Message:
Backend se jo bhi message broadcast hota hai, wo frontend me receive hota hai (socket.on('message')), 
aur uske baad wo message chat screen pe show ho jata hai.

NOTE:- ChatContext.js file mein messages ko manage karne ke liye context provide kiya gaya hai. Yahan 
messages ko add ya retrieve kiya ja sakta hai, lekin actual socket connection aur real-time communication
chatSocket.js aur ChatRoom.js files mein hi hota hai.


----------------------------------*********************************************-------------------------------


Que:- socket se hm kaise frontend and backend ko connect krte hai, means ek library do no backend and frontend 
      me use ho rhi aur isse backend and frontend connect ho jaa rhe, ye sense ke bahar ki baat nhi hai?

Ye baat bilkul samajh mein aane wali hai, aur socket communication mein ye ek common practice hai. 
Main aapko simple words mein samjhata hoon ki frontend aur backend kaise Socket.io library ke through 
connect hote hain.

-> Socket.io: Backend aur Frontend Connection Ka Bridge
Socket.io ek JavaScript library hai jo WebSockets ka use karke real-time, bi-directional communication 
ko easy banata hai. Is library ka ek part backend ke liye hota hai (Node.js server), aur ek part frontend
ke liye hota hai (browser).


1. Backend Side
Backend mein, aap Socket.io ko Node.js ke server ke sath integrate karte hain. Jaise aapne chatSocket.js
mein kiya:
const chatSocket = (io) => {
    io.on('connection', (socket) => {
        console.log('A user connected', socket.id);
        socket.on('joinRoom', (room) => {
            socket.join(room);
            console.log(`User joined room: ${room}`);
        });
        socket.on('sendMessage', (data) => {
            io.to(data.chatRoom).emit('message', data);
        });
        socket.on('disconnect', () => {
            console.log('User disconnected');
        });
    });
};
module.exports = chatSocket;

a) io.on('connection') se backend socket server pe connect hota hai.
b) Client (frontend) se messages receive karke unhe specific room mein broadcast kiya jata hai.
c) Server se ye message receive hone par, server un messages ko dusre clients tak forward kar deta hai 
   jo us room mein hain.


2. Frontend Side
Frontend mein, Socket.io ka client-side library use hota hai jo backend se directly connect hota hai. 
Jaise aapne ChatRoom.js mein kiya:

import io from 'socket.io-client';
let socket;
const ChatRoom = () => {
    // Connecting to the backend socket server
    useEffect(() => {
        socket = io('http://localhost:5000'); // Backend server ka URL
        socket.emit('joinRoom', chatRoom);

        // Listening for messages from the server
        socket.on('message', (message) => {
            setMessages((prevMessages) => [...prevMessages, message]);
        });

        return () => {
            socket.disconnect(); // Cleanup on component unmount
        };
    }, [chatRoom]);

    // Function to send message
    const sendMessage = (e) => {
        e.preventDefault();
        if (message.trim()) {
            const messageData = {
                sender: user.username,
                content: message,
                chatRoom,
            };
            socket.emit('sendMessage', messageData); // Sending message to the backend
            setMessage('');
        }
    };
    return (
        // Render messages and input form
    );
};

Yahan pe:

a) io('http://localhost:5000') se frontend, backend se connect hota hai.
b) socket.emit('sendMessage', messageData) se frontend message backend ko bhejta hai.
c) Backend se jo bhi message aata hai wo frontend pe socket.on('message') ke through receive hota hai.

-> Backend aur Frontend Kaise Interact Karte Hain?
Socket.io ka client (frontend) aur server (backend) apne respective libraries ka use karke ek doosre se
directly communicate karte hain.
-> Jab backend pe kuch specific event trigger hota hai (jaise user ne message bheja), to backend wo event
dusre clients tak emit karta hai.
-> Frontend is event ko receive karta hai aur us hisaab se UI update karta hai.

Que) Ye Sense Bana Raha Hai?
Bilkul! Isme kuch alag ya sense ke bahar nahi hai. WebSockets ka main kaam hi ye hai ki ek continuous, 
real-time connection banaye rakhe client (browser) aur server ke beech mein. Isme Socket.io middleware 
ka role play karta hai, jo ki WebSockets ko implement karna easy aur reliable banata hai.

Ye isi liye hota hai kyunki aapko baar-baar HTTP requests/response cycle follow karne ki zarurat nahi padti.
Ek baar connection establish ho jata hai, to backend aur frontend free-flowing data exchange kar sakte hain.


--------------------------------*****************************************----------------------------------

QUESTION:-
ChatRoom.js me  socket.emit('sendMessage', messageData); ye line ka chatSocket.js ki
 socket.on('sendMessage', (data) => {
            io.to(data.chatRoom).emit('message', data);
        }); 
ye line se kya connection hai aur yha  do no jgh sendMessage use kr rhe hm to ye sendMessage kya hai ,
ise kya kehte aur hm sendMessage ki jgh kuch aur variable bhi le skte hai kya? ya do no jgh sendMessage
use krne ke wjh se hi connection ho rha backend and frontend ka?


ANSWER:-
Aapne jo `sendMessage` ka use dekha, usme kuch important concepts hain jo samajhna zaroori hai. 
Main isko detail mein samjhaata hoon.

1). `sendMessage` kya hai?
`sendMessage` ek **event name** hai. Iska frontend aur backend ke beech connection establish karne mein 
 use hota hai. Event-driven programming mein, hum events define karte hain (jise yahan `sendMessage` naam 
 diya gaya hai), aur jab yeh event trigger hota hai to kuch specific action perform hota hai.

2). Kaise kaam karta hai `sendMessage`?**

#### Frontend (ChatRoom.js):

socket.emit('sendMessage', messageData);

Yahaan:
- `socket.emit` method ka use hota hai backend ko koi specific event (yahan `sendMessage`) 
   ke sath data bhejne ke liye.
- `sendMessage` event hai, aur `messageData` wo data hai jo aap backend ko bhej rahe hain
  (isme sender, content, aur chatRoom ki information hoti hai).


#### Backend (chatSocket.js):

socket.on('sendMessage', (data) => {
    io.to(data.chatRoom).emit('message', data);
});

Yahaan:
- `socket.on` method ka use hota hai backend pe kisi specific event ko listen karne ke liye (yahan `sendMessage`).
- Jab frontend se `sendMessage` event trigger hota hai, to backend is event ko listen karta hai aur receive kiye hue 
  data (`data`) ke sath kuch action perform karta hai.
- Is case mein, backend jo data receive karta hai, usse same room ke sabhi users ko forward kar deta hai
  (using `io.to(data.chatRoom).emit('message', data);`).

3). Kya hum `sendMessage` ki jagah kuch aur use kar sakte hain?
Haan, aap `sendMessage` ki jagah kuch aur event name bhi use kar sakte hain. Important yeh hai ki jo 
bhi event name aap use karein, wo frontend aur backend dono jagah consistent hona chahiye.

Agar aap `sendMessage` ki jagah kuch aur naam use karna chahte hain, to aapko frontend aur backend dono 
jagah us event name ko same rakhna hoga. Example ke liye:

#### Frontend:

socket.emit('myCustomEvent', messageData);


#### Backend:

socket.on('myCustomEvent', (data) => {
    io.to(data.chatRoom).emit('message', data);
});

Yahaan `myCustomEvent` ek custom event name hai jo aapne `sendMessage` ki jagah use kiya hai.

4). Kya frontend aur backend ka connection `sendMessage` ki waja se hi ho raha hai?
Haan, frontend aur backend ke beech connection ka ek part event names ke through hota hai. Agar event name frontend aur backend dono 
pe same nahi hoga, to backend frontend se bheja gaya event recognize nahi karega, aur aapka code kaam nahi\
karega. 

Isliye, event-driven architecture mein, yeh zaroori hai ki frontend aur backend pe jo events defined hain,
unka naam ek jaisa ho.

### Summary:
- `sendMessage` ek event name hai, jo frontend aur backend ke beech message transfer karne ke liye use hota hai.
- Event name consistent hona chahiye frontend aur backend ke beech.
- Aap `sendMessage` ki jagah koi bhi naam use kar sakte hain, bas frontend aur backend pe wo naam match karna chahiye.

------------------------------------------------*************************************---------------------------------------------------


Forgot and Reset Password ki functionality add krne ke liye hm auth.js me route, authController.js me logic
add krege, User.js me resetPasswordToken: String, resetPasswordExpires: Date, sendEmail.js new file create krege
.env file me add krege ye sb backend me krege and Frontend ke changes App.js , ResetPasswordPage.js and 
ForgotPasswordPage.js me krege






------------------------------------------------*************************************------------------------------------------------------
"""
VIMP NOTES:-
After all configuration of docker and jenkins 
Command to start Docker and Jenkins from putty

login as: ubuntu
kuch authentification ka  btayege then,

ubuntu@ip-172-31-4-63:~$ sudo systemctl start docker
ubuntu@ip-172-31-4-63:~$ sudo systemctl enable docker

Synchronizing state of docker.service with SysV service script with /usr/lib/sys                                                                                        temd/systemd-sysv-install.
Executing: /usr/lib/systemd/systemd-sysv-install enable docker

ubuntu@ip-172-31-4-63:~$ docker start jenkins
jenkins

ubuntu@ip-172-31-4-63:~$ docker ps
CONTAINER ID   IMAGE                 COMMAND                  CREATED      STATU                                                                                        S         PORTS                                                                                                                                                                              NAMES
5b021048d0fc   jenkins/jenkins:lts   "/usr/bin/tini -- /u…"   3 days ago   Up 9                                                                                         seconds   0.0.0.0:8080->8080/tcp, :::8080->8080/tcp, 0.0.0.0:50000->50000/tcp, :                                                                                        ::50000->50000/tcp   jenkins

status up means jenkins work kr rha  hai fir jenkins ko browser se open krna hai.
"""

// Connection between Docker, Jenkins, and Kubernetes:

Docker:
Docker images create karta hai jo application ko package karti hain.
Docker images ko Jenkins build aur test ke liye use karta hai.

Jenkins:
Jenkins Docker image build karta hai aur code changes ke baad automated processes ko trigger karta hai.
Jenkins Docker image ko Docker Registry me push karta hai.
Jenkins Git repository se code pull karta hai aur build, test aur deploy steps execute karta hai.

Kubernetes:
Kubernetes Docker images ko deploy karta hai aur manage karta hai.
Kubernetes scaling aur load balancing provide karta hai.

Summary:
Code Develop & Push: Developer code likhta hai aur Git repository me push karta hai.
Build & Test: Jenkins code ko pull karta hai, Docker image build karta hai, aur tests execute karta hai.
Deploy: Docker image ko Docker Registry me push karta hai, aur Kubernetes se deployment aur scaling handle karta hai.


--------------------------------**************************************------------------------------------------

EC2 par code ko Docker, Jenkins, aur Kubernetes use karke deploy karne ke liye hum ek structured process 
follow karenge.

Step 1: AWS EC2 Setup
-> EC2 Instance Create karo:

1) AWS Console pe jao aur EC2 service select karo.
2) Launch Instance par click karo, apne requirements ke hisaab se configuration set karo, jaise ki Ubuntu Server.
3) SSH Key pair generate karo aur download karlo. Is key se tum EC2 instance se connect karoge.

// SSH Key Pair Generate Karne Ka Process:
        1) EC2 Instance Create Karte Waqt Key Pair Generate Karna:
            a) AWS Console me jao aur EC2 service select karo.
            b) Launch Instance button pe click karo.
            c) Instance details fill karte waqt jab tum Key Pair (login) section me aate ho, wahan pe ek
             option milega Create new key pair.
    
        2) Key Pair Generate Karne Ke Liye Settings:
            a) Key pair name: Ye tumhara choice hai. Tum kuch bhi naam rakh sakte ho jo tumhe yaad rahe, 
              jaise my-ec2-key, project-key, etc.
            b) Key pair type: RSA select karo. Ye widely supported aur secure hai.
            c) Private key file format:
               -> .pem format select karo agar tum Linux, Mac, ya Windows (with WSL) use kar rahe ho. Ye 
                  format SSH commands ke liye suitable hai.
               -> .ppk format select karo agar tum Windows par PuTTY use kar rahe ho, lekin most cases me .pem
                   hi preferred rahega.

        4) Download the Key Pair

        // Key Pair Ko EC2 Instance Se Connect Karte Waqt Use Karna:
            ssh -i "my-ec2-key.pem" ubuntu@your-ec2-public-ip
                -i flag key file ko specify karta hai.
                "my-ec2-key.pem" tumhari key file hai jo tumne download ki thi.
                ubuntu@your-ec2-public-ip me ubuntu tumhara default username hai jo instance ke OS par depend
                karta hai, aur your-ec2-public-ip tumhara EC2 instance ka IP address hai.

4) Security group me port 22 (SSH), 80 (HTTP), 443 (HTTPS), aur 8080 (Jenkins) open karo.

NOTE:- SSH Client ek software hai jo tumhe Secure Shell (SSH) protocol ke zariye remote server (jaise EC2 instance) se
 connect hone deta hai. Iska kaam yeh hota hai ki tumhare local machine aur remote server ke beech ek secure 
 connection banaye, jisse tum command line ke through remote server ko control kar sako. Commonly used SSH 
 clients include command prompt, terminal, PuTTY, and Git Bash, jo Windows, Mac, aur Linux sabhi operating 
 systems mein kaam karte hain.

// Extra Infromation
Step-by-Step Guide to Connect EC2 Using .ppk File in PuTTY:
1) Download and Install PuTTY:
2) Open PuTTY
3) Configure PuTTY for SSH Connection:
    -> Host Name (or IP address): Enter your EC2 instance’s public DNS or IP address. You can find this in
       the AWS EC2 Dashboard under your instance details.
    -> Port: Keep this as 22 (default for SSH).
    -> Connection Type: Ensure it's set to SSH.
4) Load the .ppk File:
    -> In the PuTTY configuration window, navigate to Connection > SSH > Auth.
    -> Click on the Browse button next to the "Private key file for authentication" field.
    -> Select your .ppk file that you downloaded.
5) Connecting:
    -> After setting up the above configuration, go back to the Session tab.
    -> You can save the session settings with a name if you want to use it again.
    -> Click on the Open button to start the SSH session.
6) First Time Connection:
    If  this is your first time connecting, PuTTY may show a security alert about the server's host key. 
    Click Yes to continue.
7) Login 
    You will be prompted to enter a username. For most EC2 instances, this is usually ubuntu for Ubuntu servers
    or ec2-user for Amazon Linux servers.

Agar tum PuTTY se ubuntu@ip-172-31-4-63:~$ prompt dekh rahe ho, to iska matlab tumhara instance se 
connection establish ho gaya hai.


Step 2:- Update and Upgrade the Instance:
    sudo apt update
    sudo apt upgrade -y

Ye commands tumhare instance ko update aur upgrade karengi taake latest security patches aur software 
updates install ho sakein.


/*
NOTES:- Sudo apt install docker.io command sirf ek baar run karni hoti hai. Yeh Docker ko aapke EC2 instance 
        (ya server) pe install karne ke liye ha
// Docker Installation Details:
Jab aap yeh command run karte ho, to Docker package aapke system me install ho jata hai. Ek baar install ho
jane ke baad, aapko Docker ko fir se install karne ki zarurat nahi padegi, jab tak aap apne system ya instance
ko reset nahi karte.

Aapko sirf ek baar Docker ko install karna padega. Jab bhi aap Putty ke through apne instance pe login karenge,
Docker pehle se installed hoga, aur aap Docker commands directly use kar sakte hain.
*/


Step 3:- 
1) Install Docker: Docker ko install karne ke liye, pehle package dependencies ko install karo:
sudo apt install apt-transport-https ca-certificates curl software-properties-common -y

2) Docker Repository Add Karo:- Docker ke installation ke liye Docker ke official repository ko add karna hoga.
sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"

ERROR_NOTE:-
-> The following signatures couldn't be verified because the public key is not available: NO_PUBKEY 7EA0A9C3F273FCD8
-> Tumhe missing public key Ko download aur install karna padega. Tumhare error message me NO_PUBKEY ke saath
ek key ID di gayi hai. Us key ID ko use karke key download karo.
-> Key ID 7EA0A9C3F273FCD8 hai. Isse download aur install karne ke liye, neeche ke commands run karo:
sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 7EA0A9C3F273FCD8

Repository Update Karo:
sudo apt update

3) Docker Package List Update Karo
sudo apt update

4) Docker Install Karo
Docker CE (Community Edition) install karo:
sudo apt install docker-ce -y


5) Docker Service Start Karo
Docker service ko start karo aur ensure karo ki yeh boot ke time automatically start ho:

sudo systemctl start docker
sudo systemctl enable docker

6) Docker installation verify karne ke liye, version check karo:
docker --version


7) Docker Compose Install Karo
Docker Compose install karne ke liye:

sudo curl -L "https://github.com/docker/compose/releases/download/$(curl -s https://api.github.com/repos/docker/compose/releases/latest | grep tag_name | cut -d '\"' -f 4)/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose

Docker Compose version check karne ke liye:
docker-compose --version

8) run hello-world
Output ka matlab hai ki Docker successfully install ho gaya hai aur theek tarah se kaam kar raha hai.Tumne 
docker run hello-world command run ki thi, jo ki ek basic test command hai Docker setup verify karne ke liye.

Output Explanation:
Unable to find image 'hello-world
' locally: Docker ne local machine me "hello-world" image check ki, jo available nahi thi.
latest: Pulling from library/hello-world: Docker ne "hello-world" image ko Docker Hub se download karna start kiya.
Pull complete: Image successfully download ho gayi.
Hello from Docker!: Ye message confirm karta hai ki Docker ne successfully image ko run kiya aur output generate kiya.

Steps that happened:
Docker client ne Docker daemon ko request send ki.
Docker daemon ne "hello-world" image ko Docker Hub se pull kiya.
Docker daemon ne ek nayi container create ki jo "hello-world" executable run karta hai.
Output ko terminal me stream kiya.

---------------------------------------------------------------------------------------------------------------
Steps 4:
Ab tumhara Docker setup ready hai. Agle step me Jenkins ko setup karenge:

Jenkins Installation from terminal

1) Jenkins ke official repository ko add karo:
wget -q -O - https://pkg.jenkins.io/debian/jenkins.io.key | sudo apt-key add -
sudo sh -c 'echo deb http://pkg.jenkins.io/debian-stable binary' > /etc/apt/sources.list.d/jenkins.list

2) Package list update karo aur Jenkins install karo:
sudo apt update
sudo apt install jenkins -y


"NOTE:-Agar pehle Jenkins Docker ke through install ho chuka hai aur Docker service enable ho gayi hai, to 
Jenkins ko dubara install karne ki zarurat nahi hai. Ab Jenkins ko bas start karna hoga
docker start jenkins
Phir check karo ki Jenkins chal raha hai ya nahi:
docker ps 
Agar Jenkins container chal raha hoga, to uska status "Up" dikhai dega
 Iske baad tum apne Jenkins dashboard ko access kar sakte ho using the URL:
http://<EC2_Instance_IP>:8080/
Tumhara EC2 instance ka public IP ya DNS address tumhe AWS Management Console me mil sakta hai. 
AWS EC2 instance ka public IP address ya DNS naam generally change nahi hota hai, jab tak tum instance
ko stop aur start nahi karte ho. Lekin kuch situations me ye address change ho sakta hai:
Stop and Start Instance:
Reboot Instance:
Elastic IP (EIP): Tum elastic IP address allocate kar sakte ho, jo static hota hai aur tumhare instance ke
saath bind ho sakta hai. Isse IP address change nahi hota, aur tumhare Jenkins URL hamesha same rahega.


"


3) Jenkins service ko start karo aur ensure karo ki yeh boot ke time automatically start ho:

sudo systemctl start jenkins
sudo systemctl enable jenkins



4) Jenkins version check karne ke liye:

jenkins --version

---------------------------------------------------------------------------------------------------------------
Jenkins NOTE:-
a) Pipeline Script: Yeh step pipeline configuration me aati hai aur yahan aap frontend aur backend dono ke 
   stages define kar sakte hain.

b) Freestyle Project: Yahan aapko build steps manually configure karni hoti hain aur alag-alag commands add 
   karni hoti hain.

Hm Freestyle porject pr work kr rhe jenkins me

VIMP NOTES:- Docker logs command run karne ke liye pehle Docker service ko enable aur start karna zaroori hai.
means docker me  jenkins run krne ke liye ye sb command use  krna hoga putty open krne ke baad

### Docker Service Management

1. **Enable Docker Service:**
     sudo systemctl enable docker
    
2. **Start Docker Service:**
     sudo systemctl start docker

3. **Check Docker Service Status:**
     sudo systemctl status docker
 
4. **Verify Docker Installation:**
     docker --version

4.5 ** Agar Jenkins container nahi chal raha hai, to start karein**
     sudo docker start <jenkins_container_id>

5. **List Docker Containers:**
     sudo docker ps

6. **View Jenkins Container Logs:**
     sudo docker logs <jenkins_container_id>
     or
	 sudo docker logs jenkins
     
******
NOTE:-1. docker ps
Purpose: **List Docker Containers:**
     
2. sudo docker start jenkins
Purpose: Starts a stopped Docker container named jenkins.
*****

Step 4:-
Jenkins Install Using Docker:

NOTE:- if Docker is set up to enable and start automatically on boot, then your Jenkins container will also 
       automatically 

1) Jenkins Install Command:
docker run -d -p 8080:8080 -p 50000:50000 --name jenkins jenkins/jenkins:lts
Yeh command run karne ke baad, Jenkins Docker container background mein run hoga aur Jenkins server start 
ho jayega.

'''
NOTE:- Jenkins container is set to restart automatically:
sudo docker run --name jenkins -d --restart unless-stopped jenkins/jenkins
'''

2) Jenkins Ko Browser Mein Access Karo:
http://<your-ec2-public-ip>:8080

http://ec2-3-110-219-73.ap-south-1.compute.amazonaws.com:8080

3) Jenkins Unlock Karo:
docker exec jenkins cat /var/jenkins_home/secrets/initialAdminPassword

Jo password mile, use browser mein Jenkins unlock page par paste karo
jenkins password
04b04d0033fa41caabbe402683dd739a

4) Jenkins Setup Wizard:
    -> Jenkins ko unlock karne ke baad setup wizard aayega jisme required plugins install karo.
    -> Jenkins user account setup karo.


5) Jenkins URL:	
http://ec2-3-110-219-73.ap-south-1.compute.amazonaws.com:8080/


NOTE:- Agar aapke mobile par Jenkins dashboard open ho raha hai aur login credential maanga hai, iska matlab
hai ki aapka Jenkins server publicly accessible hai. Ye indicate karta hai ki aapne Jenkins ko sahi tarah se 
configure kiya hai aur server internet se accessible hai.

The Jenkins URL is used to provide the root URL for absolute links to various Jenkins resources. That means
this value is required for proper operation of many Jenkins features including email notifications, PR status 
updates, and the BUILD_URL environment variable provided to build steps.
The proposed default value shown is not saved yet and is generated from the current request, if possible. The
best practice is to set this value to the URL that users are expected to use. This will avoid confusion when
sharing or viewing links.


6) Logs dekhne ke liye
 docker logs jenkins


NOTES:- 
Jenkins terminal pe command not found error aa raha hai kyunki hum Jenkins ko directly Ubuntu system par install
nahi kar rahe hain; hum Jenkins ko Docker container ke andar run kar rahe hain. Docker container ke andar 
Jenkins run kar raha hai, isi liye Ubuntu terminal mein Jenkins commands directly accessible nahi hain.

Clarification:
-> Jenkins Docker Container mein install hai, Ubuntu system mein nahi.
-> Is wajah se terminal mein Jenkins ka version check nahi ho raha hai.
-> Container ke andar hi Jenkins run ho raha hai, jo Docker ke isolation feature ke wajah se Ubuntu system se alag hai.

STEP 5:- "Jenkins User ID: SyedSaab1303"

Jenkins dashboard access ho gaya hai, iska matlab Jenkins successfully setup ho chuka hai. Ab next step hai 
Jenkins pipeline setup karna, jo ki automate deployment ke liye bahut important hai. Main tumhe step-by-step 
pipeline setup karne ka process bataunga.

// Jenkins Pipeline Setup Step-by-Step:

1) Jenkins Home Dashboard:
Jenkins dashboard par ho, to "New Item" button par click karo.

2) Pipeline Job Create Karo:

Item Name: Job ka naam enter karo, jaise "My First Pipeline".
Pipeline select karo.
OK button par click karo.

3) Pipeline Configuration:

Job configuration page khul jayega.

4) Pipeline Description (Optional):

Description mein likh sakte ho ki yeh pipeline kis cheez ke liye hai.

5) Source Code Management (Git):

Source Code Management section mein "Git" option select karo.
Repository URL mein apne GitHub repo ka URL daalo jahan tumhara project code hai.
Agar repo private hai, to credentials bhi add karne honge. "Add" button se GitHub credentials add karo.



The **Source Code Management (Git)** section Jenkins me tab dikhega jab tum ek new pipeline ya freestyle job 
setup kar rahe ho. Is section ka use Jenkins ko batane ke liye hota hai ki source code ko kahan se pull karna
hai, jaise ki GitHub repository se. Yaha par steps diye gaye hain ki tumhe ye section kahan milega aur kaise 
use karoge:

1. **Jenkins Dashboard Access Karo:**
   - Jenkins server ka URL open karo, example: `http://<your-server-ip>:8080`.
   - Login karo agar required ho.

2. **New Item Create Karo:**
   - Jenkins dashboard par left side me "New Item" par click karo.
   - Ek prompt open hoga jisme tumhe apne job ka naam dena hoga.

3. **Job Type Select Karo:**
   - Tum "Pipeline" ya "Freestyle Project" select kar sakte ho, depending on your needs. 
   - "Freestyle Project" beginner-friendly hai, isiliye hum isko consider karte hain.

4. **Freestyle Project Select Karo:**
   - Freestyle Project ka naam likhne ke baad "OK" par click karo.

5. **Job Configuration Page:**
   - "Job Configuration" page open ho jayega. Isme multiple sections milenge.

6. **Source Code Management Section:**
   - Configuration page par neeche scroll karo jab tak tumhe **"Source Code Management"** section na mil jaye. 
   - Default option "None" selected hoga.

7. **Git Select Karo:**
   - "Source Code Management" section me **"Git"** option select karo.
   - Agar "Git" option nahi dikh raha, iska matlab Jenkins me Git plugin install nahi hai. Plugin Manager me jaakar "Git Plugin" install kar lo.

8. **Repository URL Enter Karo:**
   - "Repository URL" me apne GitHub repository ka URL paste karo jisme tumhara source code hosted hai. 
   - Example: `https://github.com/username/repository-name.git`.

9. **Credentials Add Karo (Agar Private Repo Hai):**
   - Agar repository private hai, to tumhe credentials add karne honge.
   - **"Add"** button se credentials add karo aur Jenkins ko batado ki GitHub access kaise karna hai.

10. **Branch Specify Karo (Optional):**
    - Agar tum specific branch ko build karna chahte ho, to branch name specify kar sakte ho jaise `main`, `frontend`, `backend`, etc.


Github personal access token:- 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


GitHub ke private repository ko Jenkins se connect karne ke liye tumhe credentials ya SSH key setup karni hoti
hai. Is setup se Jenkins ko permission mil jati hai private repo se code pull karne ki


Method 1: GitHub Credentials Setup in Jenkins

A) GitHub Personal Access Token Generate Karo:
    -> GitHub account me login karo.
    -> Top right corner me profile icon par click karo, phir "Settings" par click karo.
    -> Left sidebar me, "Developer settings" par click karo.
    -> "Personal access tokens" par click karo, phir "Tokens (classic)" section me "Generate new token" par 
        click karo.
    -> Token name: Koi bhi naam de sakte ho, jaise "Jenkins Access".
    -> Expiration: Choose karo jab tak token valid rahe, e.g., 30 days, no expiration, etc.
    -> Scopes: Minimum scopes ke liye repo scope select karo (repo access ke liye).
    -> Generate Token: "Generate token" button par click karo aur generated token ko safe jagah save kar lo.\
       Ye token sirf abhi dikh raha hai.

B) Jenkins me Credentials Add Karo:

    -> Jenkins Dashboard open karo aur "Manage Jenkins" par click karo.
    -> "Manage Credentials" par click karo.
    -> "(global)" domain par click karo, fir "Add Credentials" button par click karo.
    -> Kind: "Username with password" select karo.
    -> Username: Tumhara GitHub username daalo.
    -> Password: GitHub Personal Access Token paste karo jo abhi generate kiya tha.
    -> ID: ID optional hai, blank chhodo ya kuch recognizable daal do.
    -> Description: Example: "GitHub Token for Jenkins".
    -> Save par click karo.

C) Credentials Job Configuration Me Use Karo:

    -> Job configuration page par jao jahan tumne "Source Code Management (Git)" section setup kiya tha.
    -> Credentials dropdown se apne newly added credentials select karo.
    
 


6) Build Triggers: Decide karte hain ki build kaise trigger hoga (e.g., SCM poll ya manually).

GitHub hook trigger for GITScm polling ko Jenkins mein setup karne ka purpose ye hota hai ki jab bhi tum apne
GitHub repository mein koi commit ya push karte ho, Jenkins ko automatically notify kar diya jaye aur Jenkins
build start kar de. Ye setup karne ke liye tumhe GitHub aur Jenkins ke beech Webhooks setup karne hote hain.

Chalo step by step dekhein kaise `GitHub hook trigger for GITScm polling` setup karte hain.

### **Step 1: Jenkins Configuration for GitHub Webhooks**

1. **Install Git Plugin (if not already installed):**
   - Jenkins dashboard par jao.
   - **Manage Jenkins** > **Manage Plugins** mein jao.
   - **Available** tab mein search karo "Git plugin" aur usse install kar lo agar pehle se installed nahi hai.

2. **Go to Your Jenkins Job:**
   - Apne Jenkins dashboard par apne project/job par click karo.
   - **Configure** par click karo.

3. **Select SCM (Source Code Management):**
   - Source Code Management section mein **Git** select karo.
   - **Repository URL** mein apne GitHub repo ka URL daalo.
   - Apne credentials add karo agar tumhara repo private hai.

4. **Enable GitHub Hook Trigger:**
   - Scroll down to **Build Triggers**.
   - **GitHub hook trigger for GITScm polling** ko select karo.
   
   Iska matlab ye hai ki jab bhi GitHub par koi commit ya push hota hai, to Jenkins webhook ke zariye notify 
   ho jata hai aur build trigger hota hai.

---

### **Step 2: Set Up Webhook in GitHub**

1. **Go to Your GitHub Repository:**
   - GitHub par apne project repository page par jao.

2. **Settings > Webhooks:**
   - Repository page ke right side mein **Settings** tab par click karo.
   - Left sidebar mein **Webhooks** par click karo.

3. **Add a Webhook:**
   - **Add webhook** button par click karo.

4. **Webhook Settings:**
   - **Payload URL:** Ye URL tumhare Jenkins server ka URL hoga, jisme `/github-webhook/` bhi add karna hai.
     - Example: `http://<Jenkins-Server-URL>/github-webhook/`
     - Agar tumhara Jenkins server localhost par chal raha hai aur publicly accessible nahi hai, to tumhe 
       Jenkins ko public karne ke liye tools jaise **ngrok** use karna padega.
   
   - **Content type:** Isko `application/json` set karo.

   - **Which events would you like to trigger this webhook?**
     - Select **Just the push event**.

5. **Save the Webhook:**
   - **Add webhook** button click karke webhook save kar do.

---

### **Step 3: Testing the Webhook**

1. GitHub repository mein koi new commit ya change karo aur push karo.
2. Ab Jenkins automatically notify hoga aur webhook trigger hote hi build start kar dega.

---

### **Step 4: Verify Jenkins Build Trigger**

1. Jenkins dashboard par jaake dekho ki build automatically start hua ya nahi.
2. Agar build trigger ho gaya, to `Build History` mein latest build dikhna chahiye.

---

### **Important Notes:**

- Ensure that Jenkins server is publicly accessible if GitHub cannot directly communicate with a local server.
  - Agar Jenkins local machine pe chal raha hai aur public internet se access nahi hai, to **ngrok** jaisa tool use karo.
  
- Webhook mein `/github-webhook/` path correct hona chahiye, aur GitHub settings mein webhook ka `Payload URL` properly 
  configured hona chahiye.

---

7) Build Environment: Special environment setup agar required ho to.

Jenkins ke Build step me hmne backend ke liye  hi build  command likhe aur  ci cd  configure krege, frontend 
ke liye hm dockerfile use krege local me

8) Build Steps: Most important section, yaha tum commands likhte ho code ko build karne ke liye.

Jenkins mein frontend aur backend ke build commands ko ek hi file mein ya alag-alag files mein handle karna
dono options available hain. Lekin generally, build steps ko ek hi pipeline script ya job mein manage karna 
zyada convenient aur organized hota hai, especially jab dono frontend aur backend code same repository mein ho.

Option 1: Single Jenkins Freestyle Job
Agar aap ek hi Freestyle job mein dono frontend aur backend ke build steps handle karna chahte hain, to aap
Build Steps section mein dono sets of commands ko sequentially add kar sakte hain. Ye process step-by-step yeh hai:

a) Freestyle Job Configuration:

Source Code Management: Git repository URL aur credentials provide karein.
Build Triggers: GitHub hook trigger ya SCM polling select karein.
Build Environment: Default settings ko use karein, ya additional configurations add karein.
Build Steps:

Add Build Step: Execute shell ko select karein.

# Backend Build
cd Backend
npm install
npm run build  # Ye command optional hai agar build step define hai

# Frontend Build
cd Frontend
npm install
npm run build

Save Configuration: Job ko save karein.

/* Agar aapka Frontend folder Backend ke andar nahi hai, to aapko parent directory (..) me navigate karna padega.
# Backend Build
cd Backend
npm install
# Navigate back to root directory
cd ..
# Frontend Build
cd Frontend
npm install
npm run build
*/



9) Post-build Actions: Notifications ya build results ko handle karne ke liye isme 2 method use kr skte hai:- 

1) Artifacts Archive (Optional):
-> Backend ke Node.js project ke liye, build step usually necessary nahi hoti, kyunki Node.js applications 
ko typically directly run kiya jata hai bina build step ke
-> Jenkins build step ke dauran Backend/dist/** aur chatterbox-frontend/build/** folders ko fetch nahi karega,
balki yeh folders build process ke dauran create kiye jayenge.

// Local Build vs. Jenkins Build:
    -> Local Build: Local environment me build banane se aap code ko manually test kar sakte hain aur verify 
       kar sakte hain ki build process sahi se chal rahi hai.
    -> Jenkins Build: Jenkins aapke build commands ko automate karke execute karta hai. Jenkins build commands
       ko run karke build artifacts generate karta hai aur unhe archive kar sakta hai.

-> No Need to Push Build to GitHub:
-> Verify Jenkins Build: Jenkins job run karne ke baad, Jenkins ke build artifacts section me jaake check 
   karein ki build artifacts properly archive hue hain ya nahi.

hme build folders ko GitHub me push nahi karna hai, Jenkins ko iski chinta nahi hai. Jenkins apne build
process ke dauran yeh folders generate, create karega aur unko archive karega isliye GitHub me yeh folders
available nahi hone chahiye

Frontend build output ko aap AWS S3 bucket, AWS EC2 instance, ya kisi bhi static file hosting service par
deploy kar sakte hain.

Jenkins build artifacts ko archive karne ke baad deploy karne ke liye, aap AWS EC2 instance ya kisi bhi 
hosting environment pe deploy kar sakte hain.



npm: not found Error:
Yeh error tab aata hai jab Jenkins job ke environment me npm (Node Package Manager) installed nahi hota.
Jenkins ko npm commands run karne ke liye Node.js aur npm installed hona chahiye.


Solution:
Ensure Node.js and npm are Installed:

Aapko Jenkins ke Docker container me Node.js aur npm install karna hoga. Agar aap Jenkins ko Docker se run kar rahe hain, to aapko Dockerfile ya Jenkins ke container me manually Node.js install karna padega.

Steps to Install Node.js in Jenkins Docker Container:
jenkins-container-name is jenkins
# Jenkins container ke andar bash terminal open karein
docker exec -it <jenkins-container-name> bash          

# Node.js aur npm install karne ke liye yeh commands run karein
curl -fsSL https://deb.nodesource.com/setup_16.x | bash -
apt-get install -y nodejs

# Verify Node.js aur npm install ho gaye hain
node -v
npm -v


YE ABOVE COMMAND ROOT ME HI RUN KREGE



QUESTION:- ye command "curl -fsSL https://deb.nodesource.com/setup_16.x | bash -" run krne ke baad ye  error aa rha hai
  "E: List directory /var/lib/apt/lists/partial is missing. - Acquire (13: Permission denied) 
2024-09-15 20:16:31 - Error: Failed to run 'apt-get update' (Exit Code: 0)" 
ANSWER:- Yeh error permission issue ke wajah se aa raha hai. Aap Jenkins Docker container ke andar commands
run kar rahe hain, lekin aapko root privileges ki zarurat hai taaki apt-get update aur apt-get install 
commands execute ho sakein. Is issue ko solve karne ke liye, aapko root user ke under commands run karne 
padenge.
docker exec -it -u root <jenkins-container-name> bash


QUESTION:- abhi me  putty me jenkins ke andar hu jenkins@dcf3df937367:/$ isse kaise bahar aau ubuntu me?
ANSWER:- exit

NOTE:-
Haan, agar aap root user ke through Jenkins Docker container me Node.js aur npm install kar lete hain, to
aapko baar-baar ye commands run karne ki zaroorat nahi padegi.

A) Once Installed, Always Available:
Ek baar aap Node.js aur npm Jenkins Docker container me install kar lete hain, to wo system me tab tak 
available rahenge jab tak container running hai.
Aapke Jenkins jobs me ab npm commands directly run ho payengi bina kisi permission issue ke.

B) Container Restart Karne Ke Baad:
Agar aapka Docker container restart hota hai, tab bhi Node.js aur npm wahan installed hi rahenge, kyunki
aapne unhe container ke andar install kiya hai.
Note: Agar aap container delete karte hain aur naya Jenkins container create karte hain, tab aapko
ye installation commands phir se run karni padengi.



2) Notifications (Optional)
maine Extended E-mail Notification me SMTP server, SMTP Port then advanced option me credentials fill kra
than E-mail Notification section me SMTP server fill kra then advanced option me Use SMTP Authentication me 
User Name Password Use TLS pr tick SMTP Port and Reply-To Address fill kra then Test configuration by sending
test e-mail ko tick krke Test e-mail recipient me apna email fill krke test configuration kra isi ke saath 
saath Add Post-Build Action me Email Notification select kra aur recipients me email fill krke  Send separate
e-mails to individuals who broke the build  and Send e-mail for every unstable build pr tick kr diya
 E-mail Notification aur Extended E-mail Notification 2 different plugin hai to 2 mail aayege ek saath
gamil 2 factor authentication password :- "zkox npea tnlh mbhd"






NOTE:- Agar aapke mobile par Jenkins dashboard open ho raha hai aur login credential maanga hai, iska matlab hai ki 
aapka Jenkins server publicly accessible hai. Ye indicate karta hai ki aapne Jenkins ko sahi tarah se 
configure kiya hai aur server internet se accessible hai.


// Kya Hota Hai Agar Pipeline Script Nahi Likha?
Agar tum pipeline script nahi likhte ya usko SCM se link nahi karte, to Jenkins ko pata nahi chalega ki tumhara
build, test, aur deploy ka process kaise handle karna hai. Isliye Pipeline script likhna zaroori hota hai 
Jenkins me automate build/test/deploy karne ke liye.


-------------------------------
// yha btaya gya hai ki kaise hmne putty me docker install kra and setup and enable kra and docker me jenkins 
 install and enable kra.


ubuntu@ip-172-31-4-63:~$ sudo apt install apt-transport-https ca-certificates curl software-properties-common -y
Reading package lists... Done

ubuntu@ip-172-31-4-63:~$ sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"

ubuntu@ip-172-31-4-63:~$ sudo apt update

ubuntu@ip-172-31-4-63:~$ sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 7EA0A9C3F273FCD8

Warning: apt-key is deprecated. Manage keyring files in trusted.gpg.d instead (see apt-key(8)).

ubuntu@ip-172-31-4-63:~$ sudo apt update

ubuntu@ip-172-31-4-63:~$ sudo apt install docker-ce -y
Reading package lists... Done

ubuntu@ip-172-31-4-63:~$ sudo systemctl start docker
ubuntu@ip-172-31-4-63:~$ sudo systemctl enable docker

Executing: /usr/lib/systemd/systemd-sysv-install enable docker

ubuntu@ip-172-31-4-63:~$ docker --version
Docker version 27.2.1, build 9e34c9b

ubuntu@ip-172-31-4-63:~$ sudo curl -L "https://github.com/docker/compose/releases/download/$(curl -s https://api.github.com/repos/docker/compose/releases/latest | grep tag_name | cut -d '\"' -f 4)/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
cut: the delimiter must be a single character

ubuntu@ip-172-31-4-63:~$ sudo chmod +x /usr/local/bin/docker-compose

ubuntu@ip-172-31-4-63:~$ docker --version
Docker version 27.2.1, build 9e34c9b

ubuntu@ip-172-31-4-63:~$ sudo systemctl status docker
● docker.service - Docker Application Container Engine
     Loaded: loaded (/usr/lib/systemd/system/docker.service; enabled; preset: enabled)

ubuntu@ip-172-31-4-63:~$ docker run hello-world
docker: permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Head "http://%2Fvar%2Frun%2Fdocker.sock/_ping": dial unix /var/run/docker.sock: connect: permission denied.

ubuntu@ip-172-31-4-63:~$ sudo usermod -aG docker $USER

ubuntu@ip-172-31-4-63:~$ groups
docker adm cdrom sudo dip lxd ubuntu

ubuntu@ip-172-31-4-63:~$ docker run hello-world
Unable to find image 'hello-world:latest' locally
Hello from Docker!

ubuntu@ip-172-31-4-63:~$ docker run -d -p 8080:8080 -p 50000:50000 --name jenkins jenkins/jenkins:lts
Unable to find image 'jenkins/jenkins:lts' locally
lts: Pulling from jenkins/jenkins
903681d87777: Pull complete

ubuntu@ip-172-31-4-63:~$ docker exec jenkins cat /var/jenkins_home/secrets/initialAdminPassword
9834380a6dec4c139be28ba7b830aeb5  ( ye password change  hote rhega jb jb jenkins docker se remove krke dubara install krege)

jenkins@5b021048d0fc:/$


------------------------------------------------------------------------------------------

VS Code se apna code GitHub branch me push karne ke liye tumhe steps follow karne padenge.

Scenario 1: Single Repository for Both Frontend and Backend

Step 1: Create a Single Repository on GitHub :- GitHub par jao aur "New Repository" par click karo.

Step 2: Clone the Repository in VS Code
git clone https://github.com/username/chat-application.git
Isse tumhara GitHub repository local machine par clone ho jayega.

Step 3: Copy Your Project Code to the Cloned Folder

"Copy Your Project Code to the Cloned Folder" ka matlab hai ki tum apne existing project code ko us folder me
 move ya copy karoge jo tumne GitHub se clone kiya hai. Ye steps follow karo:

Step a: Locate Your Project Folder

Apne computer par jaha tumhara existing project code (frontend aur backend) pada hai, us folder ko locate karo.
Example: Agar tumhara project code D:/MyProjects/ChatApp me hai, to us folder ko open karo.

Step b: Open the Cloned Folder
Ye woh folder hoga jo tumne GitHub se clone kiya tha.
Example: Agar tumne chat-application naam se clone kiya tha, to ye folder C:/Users/YourName/chat-application me hoga.

Step c: Copy Project Code
Step d: Paste into Cloned Folder
Step e: Verify the Copy



Step 4: Initialize Git in Your Project (If Not Already Initialized)
git init

All Files ko Git mein Add karo:
git add .

Initial Commit karo:
git commit -m "Initial commit"

Step 5: Link Local Repository with Remote GitHub Repository
git remote add origin https://github.com/username/chat-application.git

Step 6: Push Code to GitHub
Branch create karo (if not on main or master):
git branch -M main

Code ko GitHub par Push karo:
git push -u origin main

---------------------------------------------------------------------

NOTES

Jenkins aapke EC2 instance par ek application ke roop mein run ho raha hota hai. Jab hum keh rahe hain 
"server (EC2 instance) ke operating system ko modify karengi," to iska matlab hai ki hum wo commands run 
kar rahe hain jo aapke EC2 instance ke operating system (jaise Ubuntu) par directly effect daalengi.

### Jenkins aur EC2 Instance:

1. **EC2 Instance:**
   - EC2 (Elastic Compute Cloud) instance ek virtual server hai jo AWS (Amazon Web Services) ke cloud me run
     hota hai.
   - Ye server aapke operating system, files, aur applications ko host karta hai. 

2. **Jenkins:**
   - Jenkins ek continuous integration (CI) tool hai jo aapke EC2 instance par install hota hai aur run 
     karta hai.
   - Jenkins ka role hai build automation, test automation, aur deployment automation manage karna.

### Kaise Pata Karein Ki Jenkins Kaunse Server Par Run Ho Raha Hai?

1. **EC2 Instance me Jenkins Installation:**
   - Jab aap Jenkins install karte hain, to wo aapke EC2 instance par install hota hai. Jenkins ko ek
     service ke roop me run karte hain, jo aapke EC2 instance ke operating system ke resources ko use karta
     hai.

2. **Checking Jenkins:**
   - Agar aap Jenkins ko access kar rahe hain web browser se, to aap usually `http://<your-ec2-public-ip>:8080`
     par Jenkins dashboard ko dekh sakte hain.
   - Ye IP address aapka EC2 instance ka public IP hai, jahan Jenkins run kar raha hai.

3. **Jenkins Configuration and Build Steps:**
   - Jenkins build steps aapke code ko build karne ke liye hain aur yeh build steps EC2 instance ke operating
     system me execute hote hain. 
   - Jab aap build steps me commands likhte hain (jaise `npm install` aur `npm run build`), to yeh commands
     Jenkins ke environment me execute hoti hain, jo EC2 instance ke operating system ke resources ko use
     karte hain.

Iska matlab hai ki aapko Jenkins build steps ko configure karte waqt ensure karna hoga ki aapka EC2 instance 
(jahan Jenkins run ho raha hai) sahi tarah se setup hai, aur saare necessary tools aur dependencies install
 hain.
-----------------------

Question:- ye  command 'docker run -d -p 8080:8080 -p 50000:50000 --name jenkins jenkins/jenkins:lts' ke baad ye output
 me mila "dcf3df937367c667cbf195909d2092dca7f9d0d007115ca989e6b71e955aa551"

ANSWER:- the output you received (dcf3df937367c667cbf195909d2092dca7f9d0d007115ca989e6b71e955aa551) is the unique ID of the
Jenkins container that was just created. This means Jenkins is now running in a Docker container with this ID.


